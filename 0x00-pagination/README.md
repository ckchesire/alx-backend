## Pagination

Pagination is a crucial feature for REST API endpoints that return lists of entities, particularly when dealing with potentially large datasets, to prevent excessive network traffic by returning millions or billions of items in a single response. It relies on an **implied ordering** of items, which can be by a unique identifier or another ordered field like creation date. The simplest form is **Offset Pagination**, which leverages the `LIMIT` and `OFFSET` keywords common in SQL databases. This method is the **easiest to implement** and is **stateless** on the server. However, it suffers from **poor performance for large offset values** as the database must scan previous rows, and it is **not consistent when new items are inserted** (known as Page drift), potentially causing items to be missed or duplicated. Despite these drawbacks, offset paging is easy to understand and suitable for applications with smaller data sets.

To address the limitations of offset pagination, the following are used **Keyset Pagination** and **Seek Pagination**. Keyset pagination uses **filter values from the last page's results** to fetch the next set, working well with existing filters and offering **consistent ordering and performance** even with large offsets. Its downsides include **tight coupling** to filters/sorting, ineffectiveness for **low cardinality fields**, and complexity for clients using custom sort fields. **Seek Pagination** extends keyset paging by using an `after_id` or `start_id` parameter, removing the tight coupling to filters. It provides **consistent ordering and performance** and avoids issues with low cardinality fields due to the high cardinality of unique IDs. While more **complex for the backend to implement**, potentially requiring multiple queries for custom sorting, and having a slight risk if the `start_id` is for a deleted item, Seek paging is considered a **good overall strategy** as it keeps client-side complexity low while remaining performant.

## Hypermedia as the engine of application state (HATEOAS)

**HATEOAS**, which stands for **Hypermedia as the engine of application state**, is a **constraint of the REST software architectural style** that serves to distinguish it from other network architectural styles. With HATEOAS, a client interacts with a network application where the servers dynamically provide information through **hypermedia**. This means a REST client needs minimal prior knowledge about how to interact with an application or server, beyond a general understanding of hypermedia. This contrasts with systems like CORBA, where clients and servers rely on a fixed interface defined through documentation or an interface description language (IDL). The constraints imposed by HATEOAS are intended to **decouple the client and server**, allowing server functionality to evolve independently. The term was coined in 2000 by Roy Fielding in his doctoral dissertation, and he explained that the strictness of this and other REST constraints is meant to promote **software longevity and independent evolution over decades**, sometimes at the expense of short-term efficiency.

In a system following HATEOAS, interaction typically begins with an initial HTTP request to an entry point URL, but all subsequent requests the user-agent might make are discovered within the response to each request. The client transitions through different application states by selecting from the links provided within a representation or by manipulating the representation as allowed by its media type. This approach means that **RESTful interaction is driven by hypermedia**, rather than relying on out-of-band information. This is the core of the term "**Engine of Application State**". What actions are possible for a client varies as the state of the resource changes. For example, a healthy account resource might return links for deposits, withdrawals, and transfers, but if the account becomes overdrawn, a subsequent response might only include a link for deposits, reflecting the change in the account's state. A client doesn't need to understand every media type provided; the ability to understand new types can potentially be acquired at runtime through "code-on-demand" from the server. While HTML inherently supports hypermedia, various media types and technologies like HAL, Siren, Collection+JSON, JSON:API, and Hydra have been developed to incorporate hypermedia concepts into formats like JSON or XML.
